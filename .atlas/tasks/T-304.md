---
id: T-304
type: task
status: todo
priority: high
parent_spec: 003-benchmark-cli.md
---

# Store Client

Implement the HTTP client for interacting with the player service's store purchase endpoint.

## Sub-tasks:

- [x] **Create StoreClient struct**: Define struct in `internal/client/store.go` with HTTP client and config fields
- [x] **Implement NewStoreClient**: Constructor that accepts config and creates an HTTP client with connection pooling enabled

---

- [x] **Define request/response types in `internal/client/store.go`**
  - `PurchaseRequest` struct with fields:
    - `PlayerID string` (json:"playerId") - the player making the purchase
    - `ItemID string` (json:"itemId") - the item being purchased
    - `Quantity int` (json:"quantity") - number of items to purchase
  - `PurchaseResponse` struct with fields:
    - `Success bool` (json:"success") - whether purchase succeeded
    - `TransactionID string` (json:"transactionId") - unique transaction identifier
    - `NewBalance int` (json:"newBalance") - player's currency balance after purchase
    - `Error string` (json:"error,omitempty") - error message if purchase failed
  - `PurchaseResult` struct (returned to caller) with fields:
    - `Response *PurchaseResponse` - the API response
    - `Latency time.Duration` - time taken for the request

---

- [x] **Implement Purchase method in `internal/client/store.go`**
  - Signature: `func (c *StoreClient) Purchase(ctx context.Context, req PurchaseRequest) (*PurchaseResult, error)`
  - Record start time: `start := time.Now()`
  - Build request URL: `c.config.PlayerServiceURL + "/api/store/purchase"`
  - Serialize request body to JSON using `json.Marshal(req)`
  - Create `http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))`
  - Set header: `Content-Type: application/json`
  - Execute request with `c.client.Do(req)`
  - Calculate latency: `latency := time.Since(start)`
  - If status code is not 200:
    - Read response body for error message
    - Return `nil, &APIError{StatusCode: resp.StatusCode, Message: body}`
  - Deserialize response body into `PurchaseResponse` using `json.NewDecoder(resp.Body).Decode()`
  - Return `&PurchaseResult{Response: &resp, Latency: latency}, nil`

---

- [x] **Define custom error types in `internal/client/errors.go`** (if not already present)
  - `var ErrInsufficientFunds = errors.New("insufficient funds for purchase")`
  - `var ErrItemNotFound = errors.New("item not found in store")`
  - `var ErrInvalidQuantity = errors.New("quantity must be greater than zero")`
  - Reuse `APIError` struct from matchmaker client if already defined

---

- [x] **Add context cancellation support**
  - All HTTP requests must be created with `http.NewRequestWithContext(ctx, ...)`
  - Check `ctx.Err()` before making request, return early if already cancelled
  - Ensure `resp.Body.Close()` is deferred immediately after successful `client.Do()` call
  - When `ctx.Done()` fires during request, `client.Do()` returns `context.Canceled` or `context.DeadlineExceeded`

---

- [x] **Write unit tests in `internal/client/store_client_test.go`**
  - Use `httptest.NewServer` to mock the player service
  - Test `Purchase()` success case: returns valid `PurchaseResult` with response and latency
  - Test `Purchase()` with insufficient funds: returns appropriate error
  - Test `Purchase()` with invalid item: returns appropriate error
  - Test `Purchase()` with server error (5xx): returns `APIError` with status code
  - Test latency tracking: verify `Latency` field is populated and reasonable
  - Test context cancellation: verify requests abort when context is cancelled
