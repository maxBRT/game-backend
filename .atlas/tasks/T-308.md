---
id: T-308
type: task
status: todo
priority: high
parent_spec: 003-benchmark-cli.md
---

# Benchmark Runner

Implement the orchestrator that manages the lifecycle of all simulated players and purchasers.

## Sub-tasks:

- [ ] **Create Runner struct in `internal/benchmark/runner.go`**
  - Fields:
    - `config *config.Config` - service URLs and HTTP settings
    - `matchClient *client.MatchClient` - shared matchmaker client
    - `storeClient *client.StoreClient` - shared store client
    - `metrics *Metrics` - metrics collector
    - `survivors int` - number of survivor players to spawn
    - `killers int` - number of killer players to spawn
    - `duration time.Duration` - total benchmark duration
    - `rampUp time.Duration` - time to spawn all players
    - `purchasesPerSec int` - target purchase rate
    - `wg sync.WaitGroup` - for waiting on all goroutines
    - `metricsCallback func(MetricsSnapshot)` - callback for dashboard updates

---

- [ ] **Create RunnerParams struct for constructor**
  - `Survivors int`
  - `Killers int`
  - `Duration time.Duration`
  - `RampUp time.Duration`
  - `PurchasesPerSec int`

---

- [ ] **Implement NewRunner constructor**
  - Signature: `func NewRunner(cfg *config.Config, params RunnerParams) (*Runner, error)`
  - Validate parameters:
    - `params.Survivors >= 0`
    - `params.Killers >= 0`
    - `params.Duration > 0`
    - `params.RampUp >= 0 && params.RampUp < params.Duration`
    - `params.PurchasesPerSec >= 0`
  - Create MatchClient: `client.NewMatchClient(cfg)`
  - Create StoreClient: `client.NewStoreClient(cfg)`
  - Create Metrics: `NewMetrics()`
  - Return populated Runner

---

- [ ] **Implement SetMetricsCallback method**
  - Signature: `func (r *Runner) SetMetricsCallback(cb func(MetricsSnapshot))`
  - Store callback for dashboard to receive periodic updates
  - Dashboard calls this before `Start()` to register interest

---

- [ ] **Implement Start method**
  - Signature: `func (r *Runner) Start(ctx context.Context) (*Results, error)`
  - Create cancellable context: `ctx, cancel := context.WithCancel(ctx)`
  - Defer `cancel()` to ensure all goroutines stop
  - Start metrics snapshot goroutine (see below)
  - Start purchaser goroutines immediately (see below)
  - Start player ramp-up goroutine (see below)
  - Wait for duration or context cancellation:
    ```go
    select {
    case <-ctx.Done():
        // External cancellation
    case <-time.After(r.duration):
        // Benchmark complete
    }
    ```
  - Call `cancel()` to signal all goroutines to stop
  - Wait for all goroutines: `r.wg.Wait()`
  - Return final results: `r.buildResults()`

---

- [ ] **Implement metrics snapshot goroutine**
  - Spawned in `Start()`:
    ```go
    r.wg.Add(1)
    go func() {
        defer r.wg.Done()
        ticker := time.NewTicker(200 * time.Millisecond)
        defer ticker.Stop()
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                if r.metricsCallback != nil {
                    r.metricsCallback(r.metrics.Snapshot())
                }
            }
        }
    }()
    ```

---

- [ ] **Implement ramp-up logic in spawnPlayers method**
  - Signature: `func (r *Runner) spawnPlayers(ctx context.Context)`
  - Calculate total players: `total := r.survivors + r.killers`
  - If rampUp is 0, spawn all immediately
  - Otherwise, calculate spawn interval: `interval := r.rampUp / time.Duration(total)`
  - Create spawn order: interleave survivors and killers based on ratio
    ```go
    // Example: 100 survivors, 25 killers â†’ spawn 4 survivors, then 1 killer, repeat
    survivorRatio := float64(r.survivors) / float64(total)
    ```
  - Spawn loop:
    ```go
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    survivorCount, killerCount := 0, 0
    for i := 0; i < total; i++ {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            role := determineNextRole(survivorCount, killerCount, survivorRatio)
            r.spawnPlayer(ctx, role, survivorCount+killerCount)
            if role == "survivor" { survivorCount++ } else { killerCount++ }
        }
    }
    ```

---

- [ ] **Implement spawnPlayer helper**
  - Signature: `func (r *Runner) spawnPlayer(ctx context.Context, role string, id int)`
  - Create player: `NewPlayer(id, role, r.matchClient, r.metrics, WithRequeue(true))`
  - Increment wait group: `r.wg.Add(1)`
  - Start goroutine:
    ```go
    go func() {
        defer r.wg.Done()
        player.Run(ctx)
    }()
    ```

---

- [ ] **Implement purchaser spawning**
  - Called in `Start()` before ramp-up begins
  - Determine number of purchaser goroutines (e.g., min(purchasesPerSec, 10) goroutines)
  - Distribute rate: `rates := DistributePurchasers(float64(r.purchasesPerSec), numGoroutines)`
  - Spawn each purchaser:
    ```go
    for i, rate := range rates {
        purchaser := NewPurchaser(i, r.storeClient, r.metrics, rate)
        r.wg.Add(1)
        go func() {
            defer r.wg.Done()
            purchaser.Run(ctx)
        }()
    }
    ```

---

- [ ] **Implement buildResults method**
  - Signature: `func (r *Runner) buildResults() *Results`
  - Take final snapshot: `snap := r.metrics.Snapshot()`
  - Populate Results struct with all final values

---

- [ ] **Define Results struct**
  - `MatchesFormed int64`
  - `PeakMatchesPerSec float64`
  - `AvgTimeToMatch time.Duration`
  - `P95TimeToMatch time.Duration`
  - `P99TimeToMatch time.Duration`
  - `Purchases int64`
  - `PeakPurchasesPerSec float64`
  - `AvgPurchaseLatency time.Duration`
  - `P95PurchaseLatency time.Duration`
  - `P99PurchaseLatency time.Duration`
  - `TotalRequests int64`
  - `Errors int64`
  - `ErrorRate float64`
  - `Duration time.Duration`

---

- [ ] **Write unit tests in `internal/benchmark/runner_test.go`**
  - Test parameter validation in NewRunner
  - Test ramp-up timing (mock time or use short durations)
  - Test graceful shutdown (context cancellation)
  - Test metrics callback is called periodically
  - Test results are populated correctly after run
