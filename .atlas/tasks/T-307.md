---
id: T-307
type: task
status: todo
priority: medium
parent_spec: 003-benchmark-cli.md
---

# Purchaser Simulation

Implement the simulated purchaser goroutine that makes store purchases at a target rate.

## Sub-tasks:

- [ ] **Create Purchaser struct in `internal/benchmark/purchaser.go`**
  - Fields:
    - `id int` - unique identifier for this purchaser goroutine
    - `client *client.StoreClient` - shared HTTP client for store service
    - `metrics *Metrics` - shared metrics collector
    - `targetRatePerSec float64` - purchases per second this goroutine should achieve
    - `rng *rand.Rand` - random number generator (seeded per-goroutine to avoid contention)

---

- [ ] **Implement NewPurchaser constructor**
  - Signature: `func NewPurchaser(id int, client *client.StoreClient, metrics *Metrics, targetRatePerSec float64) *Purchaser`
  - Create seeded RNG: `rng := rand.New(rand.NewSource(time.Now().UnixNano() + int64(id)))`
  - Store all fields in struct

---

- [ ] **Implement Run method**
  - Signature: `func (p *Purchaser) Run(ctx context.Context)`
  - Calculate interval between purchases: `interval := time.Duration(float64(time.Second) / p.targetRatePerSec)`
  - Create ticker: `ticker := time.NewTicker(interval)`
  - Defer `ticker.Stop()`
  - Main loop:
    ```go
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            p.executePurchase(ctx)
        }
    }
    ```

---

- [ ] **Implement executePurchase method**
  - Signature: `func (p *Purchaser) executePurchase(ctx context.Context)`
  - Generate random purchase request using `p.generatePurchaseRequest()`
  - Call `p.client.Purchase(ctx, req)`
  - If error:
    - `p.metrics.RecordError()`
    - Log error at debug level (don't spam logs)
    - Return (continue to next purchase)
  - Record successful purchase: `p.metrics.RecordPurchase(result.Latency)`

---

- [ ] **Implement generatePurchaseRequest method**
  - Signature: `func (p *Purchaser) generatePurchaseRequest() client.PurchaseRequest`
  - Generate random player ID: `fmt.Sprintf("player-%d", p.rng.Intn(10000))`
  - Generate random item ID from predefined list:
    ```go
    items := []string{"health-potion", "mana-potion", "sword", "shield", "armor", "boots", "helmet", "ring"}
    itemID := items[p.rng.Intn(len(items))]
    ```
  - Generate random quantity: `quantity := p.rng.Intn(5) + 1` (1-5 items)
  - Return populated `PurchaseRequest`

---

- [ ] **Implement load distribution helper**
  - Signature: `func DistributePurchasers(totalRate float64, numGoroutines int) []float64`
  - Divide total target rate evenly among goroutines
  - Handle remainder by giving extra to first few goroutines
  - Example: totalRate=100, numGoroutines=3 â†’ [34, 33, 33]
  - Used by Runner to spawn multiple purchasers with correct individual rates

---

- [ ] **Add jitter to prevent thundering herd**
  - In `Run()`, before starting ticker, sleep for random duration:
    ```go
    jitter := time.Duration(p.rng.Int63n(int64(interval)))
    select {
    case <-ctx.Done():
        return
    case <-time.After(jitter):
    }
    ```
  - This staggers purchasers so they don't all fire at the same instant

---

- [ ] **Write unit tests in `internal/benchmark/purchaser_test.go`**
  - Use mock StoreClient that returns controlled responses
  - Test rate limiting: verify purchases happen at approximately target rate
  - Test error handling: verify errors are recorded, purchaser continues
  - Test context cancellation: exits cleanly
  - Test random data generation: verify valid player IDs, item IDs, quantities
  - Test load distribution: verify `DistributePurchasers` math is correct
