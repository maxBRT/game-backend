---
id: T-309
type: task
status: todo
priority: medium
parent_spec: 003-benchmark-cli.md
---

# TUI Dashboard

Implement the real-time terminal dashboard using bubbletea that displays live benchmark metrics.

## Sub-tasks:

- [ ] **Create Dashboard model struct in `internal/dashboard/dashboard.go`**
  - Fields:
    - `snapshot benchmark.MetricsSnapshot` - current metrics to display
    - `totalDuration time.Duration` - benchmark duration for progress display
    - `width int` - terminal width
    - `height int` - terminal height
    - `quitting bool` - whether user requested quit
    - `done bool` - whether benchmark completed
    - `snapshotChan <-chan benchmark.MetricsSnapshot` - receives metrics updates

---

- [ ] **Define custom message types**
  - `type tickMsg time.Time` - periodic refresh trigger
  - `type snapshotMsg benchmark.MetricsSnapshot` - new metrics received
  - `type doneMsg struct{}` - benchmark completed

---

- [ ] **Implement New constructor**
  - Signature: `func New(totalDuration time.Duration, snapshotChan <-chan benchmark.MetricsSnapshot) *Dashboard`
  - Initialize with zero snapshot and provided duration
  - Store snapshot channel for receiving updates

---

- [ ] **Implement Init method**
  - Signature: `func (d Dashboard) Init() tea.Cmd`
  - Return batch of commands:
    - `tea.Batch(d.tickCmd(), d.waitForSnapshot())`
  - `tickCmd` returns a `tea.Tick` that fires every 100ms
  - `waitForSnapshot` returns a command that waits on snapshotChan

---

- [ ] **Implement waitForSnapshot command**
  - Signature: `func (d Dashboard) waitForSnapshot() tea.Cmd`
  - Return function that:
    - Receives from `d.snapshotChan`
    - Returns `snapshotMsg` with received snapshot
    - Returns `doneMsg` if channel is closed

---

- [ ] **Implement Update method**
  - Signature: `func (d Dashboard) Update(msg tea.Msg) (tea.Model, tea.Cmd)`
  - Handle message types:
    ```go
    switch msg := msg.(type) {
    case tea.KeyMsg:
        if msg.String() == "q" || msg.String() == "ctrl+c" {
            d.quitting = true
            return d, tea.Quit
        }
    case tea.WindowSizeMsg:
        d.width = msg.Width
        d.height = msg.Height
    case tickMsg:
        return d, d.tickCmd()
    case snapshotMsg:
        d.snapshot = benchmark.MetricsSnapshot(msg)
        return d, d.waitForSnapshot()
    case doneMsg:
        d.done = true
        return d, tea.Quit
    }
    ```

---

- [ ] **Implement View method**
  - Signature: `func (d Dashboard) View() string`
  - If quitting: return "Stopping benchmark..."
  - Build layout using lipgloss styles (see below)
  - Return complete rendered string

---

- [ ] **Create lipgloss styles in `internal/dashboard/styles.go`**
  - `boxStyle` - border style for main container:
    ```go
    boxStyle := lipgloss.NewStyle().
        Border(lipgloss.DoubleBorder()).
        BorderForeground(lipgloss.Color("63")).
        Padding(0, 1)
    ```
  - `headerStyle` - centered, bold title
  - `sectionHeaderStyle` - section titles (MATCHMAKER, STORE, TOTALS)
  - `labelStyle` - metric labels (left-aligned, dimmed)
  - `valueStyle` - metric values (right-aligned, bright)
  - `dividerStyle` - horizontal line between sections

---

- [ ] **Implement renderHeader helper**
  - Signature: `func (d *Dashboard) renderHeader() string`
  - Render "BACKEND BENCHMARK" centered
  - Render duration progress: format as "Duration: MM:SS / MM:SS"
  - Use `formatDuration(d.snapshot.ElapsedTime)` and `formatDuration(d.totalDuration)`

---

- [ ] **Implement renderMatchmakerSection helper**
  - Signature: `func (d *Dashboard) renderMatchmakerSection() string`
  - Render section header: "MATCHMAKER"
  - Render metrics in two-column format:
    - `Survivors waiting:` + `d.snapshot.SurvivorsWaiting`
    - `Killers waiting:` + `d.snapshot.KillersWaiting`
    - `Matches formed:` + `formatNumber(d.snapshot.MatchesFormed)`
    - `Matches/sec:` + `fmt.Sprintf("%.1f", d.snapshot.MatchesPerSec)`
    - `Avg time-to-match:` + `formatDurationMs(d.snapshot.AvgTimeToMatch)`

---

- [ ] **Implement renderStoreSection helper**
  - Signature: `func (d *Dashboard) renderStoreSection() string`
  - Render section header: "STORE"
  - Render metrics:
    - `Purchases:` + `formatNumber(d.snapshot.Purchases)`
    - `Purchases/sec:` + `fmt.Sprintf("%.1f", d.snapshot.PurchasesPerSec)`
    - `Avg latency:` + `formatDurationMs(d.snapshot.AvgPurchaseLatency)`
    - `Errors:` + `d.snapshot.Errors`

---

- [ ] **Implement renderTotalsSection helper**
  - Signature: `func (d *Dashboard) renderTotalsSection() string`
  - Render section header: "TOTALS"
  - Render metrics:
    - `Active connections:` + `d.snapshot.ActiveConnections`
    - `Total requests:` + `formatNumber(d.snapshot.TotalRequests)`
    - `Error rate:` + `fmt.Sprintf("%.2f%%", d.snapshot.ErrorRate*100)`

---

- [ ] **Implement formatting helpers in `internal/dashboard/format.go`**
  - `func formatDuration(d time.Duration) string` - returns "MM:SS" format
  - `func formatDurationMs(d time.Duration) string` - returns "XXms" format
  - `func formatNumber(n int64) string` - returns comma-separated number (e.g., "1,234")

---

- [ ] **Implement side-by-side layout for matchmaker/store**
  - Use `lipgloss.JoinHorizontal()` to place matchmaker and store sections side by side
  - Add vertical divider between them: `â”‚`
  - Ensure columns are equal width

---

- [ ] **Handle minimum terminal size**
  - If `d.width < 64` or `d.height < 15`:
    - Return message: "Terminal too small. Resize to at least 64x15."
  - Dashboard needs minimum size to render properly

---

- [ ] **Write unit tests in `internal/dashboard/dashboard_test.go`**
  - Test View output contains expected sections
  - Test formatting helpers return correct strings
  - Test Update handles key messages correctly
  - Test WindowSizeMsg updates dimensions
