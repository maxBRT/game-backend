---
id: T-306
type: task
status: todo
priority: medium
parent_spec: 003-benchmark-cli.md
---

# Player Simulation

Implement the simulated player goroutine that joins matchmaking, polls for match status, and makes store purchases using real player IDs from the player service.

**Important:** Player IDs must come from the seeded player service database (IDs 1-100). The matchmaker accepts any ID, but store purchases require valid player IDs that exist in the database.

## Sub-tasks:

- [ ] **Create Player struct in `internal/benchmark/player.go`**
  - Fields:
    - `id int` - player ID from player service (1-100 range)
    - `name string` - display name fetched from player service or generated
    - `role string` - either "survivor" or "killer" (for matchmaking)
    - `matchClient *client.MatchClient` - HTTP client for matchmaker service
    - `storeClient *client.StoreClient` - HTTP client for player service store
    - `metrics *Metrics` - shared metrics collector
    - `pollInterval time.Duration` - how often to poll match status (default 150ms)
    - `requeue bool` - whether to rejoin queue after match completes
    - `makePurchases bool` - whether to simulate store purchases between matches

---

- [ ] **Implement NewPlayer constructor**
  - Signature: `func NewPlayer(playerID int, role string, matchClient *client.MatchClient, storeClient *client.StoreClient, metrics *Metrics, opts ...PlayerOption) *Player`
  - playerID must be in range 1-100 (seeded players in player service)
  - Generate name: `fmt.Sprintf("Player-%d", playerID)` (or fetch from player service)
  - Set default poll interval to 150ms
  - Apply any functional options (for customizing poll interval, requeue, purchases)

---

- [ ] **Implement Run method**
  - Signature: `func (p *Player) Run(ctx context.Context)`
  - Main loop structure:
    ```go
    for {
        select {
        case <-ctx.Done():
            return
        default:
            if err := p.playOneRound(ctx); err != nil {
                if ctx.Err() != nil {
                    return // Context cancelled, exit cleanly
                }
                p.metrics.RecordError()
                // Brief backoff before retry
                time.Sleep(500 * time.Millisecond)
            }
            if !p.requeue {
                return
            }
        }
    }
    ```

---

- [x] **Implement playOneRound method**
  - Signature: `func (p *Player) playOneRound(ctx context.Context) error`
  - Record start time: `joinTime := time.Now()`
  - Increment waiting count based on role:
    - If survivor: `p.metrics.IncrSurvivorsWaiting()`
    - If killer: `p.metrics.IncrKillersWaiting()`
  - Defer decrement of waiting count (ensures cleanup on any exit path)
  - Create `PlayerInfo{ID: fmt.Sprintf("%d", p.id), Name: p.name, Role: p.role}`
  - Call `p.matchClient.Join(ctx, playerInfo)` to get ticket
  - If error, return error (waiting count decremented by defer)
  - Poll for match status in loop (see next sub-task)
  - On match found: calculate `timeToMatch := time.Since(joinTime)`
  - Record match: `p.metrics.RecordMatch(timeToMatch)`
  - If `p.makePurchases`, call `p.simulatePurchase(ctx)` after match
  - Return nil

---

- [x] **Implement status polling loop**
  - Create ticker: `ticker := time.NewTicker(p.pollInterval)`
  - Defer `ticker.Stop()`
  - Loop:
    ```go
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-ticker.C:
            status, err := p.matchClient.Status(ctx, ticket.TicketID)
            if err != nil {
                return fmt.Errorf("status check failed: %w", err)
            }
            if status.Status == "matched" {
                return nil // Match found!
            }
            // status.Status == "waiting", continue polling
        }
    }
    ```
  - Note: The server uses long-polling, so Status() may block for a while before returning

---

- [x] **Implement simulatePurchase method**
  - Signature: `func (p *Player) simulatePurchase(ctx context.Context)`
  - Select a random item ID (1-100 range from seeded items)
  - Create purchase request with real player ID:
    ```go
    req := client.PurchaseRequest{
        PlayerId: p.id,      // Real player ID from player service
        ItemId:   randomItemID,
        Amount:   1,
    }
    ```
  - Record start time for latency tracking
  - Call `p.storeClient.Purchase(ctx, req)`
  - Record purchase metrics:
    - On success: `p.metrics.RecordPurchase(latency)`
    - On ErrInsufficientFunds: `p.metrics.RecordInsufficientFunds()` (expected, not an error)
    - On other errors: `p.metrics.RecordPurchaseError()`

---

- [x] **Implement proper cleanup with defer**
  - Use defer immediately after incrementing waiting count:
    ```go
    if p.role == "survivor" {
        p.metrics.IncrSurvivorsWaiting()
        defer p.metrics.DecrSurvivorsWaiting()
    } else {
        p.metrics.IncrKillersWaiting()
        defer p.metrics.DecrKillersWaiting()
    }
    ```
  - This ensures waiting counts are always decremented, even on:
    - Context cancellation
    - Join errors
    - Status polling errors
    - Successful match

---

- [x] **Define PlayerOption functional options**
  - `func WithPollInterval(d time.Duration) PlayerOption`
  - `func WithRequeue(requeue bool) PlayerOption`
  - `func WithPurchases(enabled bool) PlayerOption`
  - Example usage: `NewPlayer(42, "survivor", matchClient, storeClient, metrics, WithPurchases(true))`

---

- [x] **Write unit tests in `internal/benchmark/player_test.go`**
  - Use mock MatchClient and StoreClient that return controlled responses
  - Test successful match flow: join -> poll -> matched
  - Test join error handling: error recorded, waiting count not stuck
  - Test status error handling: error recorded, waiting count decremented
  - Test context cancellation: exits cleanly, waiting count decremented
  - Test requeue behavior: player rejoins after match when requeue=true
  - Test metrics recording: verify timeToMatch is recorded accurately
  - Test purchase flow: verify real player ID is used (not synthetic)
  - Test purchase error handling: insufficient funds handled gracefully
